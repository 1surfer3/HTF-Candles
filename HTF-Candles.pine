// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © 

//@version=6
indicator('HTF Candles', overlay = true, max_boxes_count = 500, max_lines_count = 500, max_labels_count = 500, max_bars_back = 5000)

type Candle
	float o
	float c
	float h
	float l
	int o_idx
	box body
	line wick_up
	line wick_down

type CandleSettings
	string htf

type CandleSet
	array<Candle> candles
	CandleSettings settings
	label tfNameTop
	label tfTimerTop

type Helper
	string name = 'Helper'

// 1. INPUT SETTINGS

// --- A. Timeframe & History ---
string group_htf = "A. TIMEFRAME & HISTORY"

i_htf_choice = input.string(title="1. Select HTF", defval="1H", options=["5m", "15m", "30m", "1H", "4H", "1D", "1W", "1M"], group=group_htf, inline="htf_set")
max_display_count = input.int(title="Max Candles", defval=4, minval=1, maxval=10, group=group_htf, inline="htf_set") 

// Map selection to Pine Script format
htfTimeframe = switch i_htf_choice
    "5m"  => "5"
    "15m" => "15"
    "30m" => "30"
    "1H"  => "60"
    "4H"  => "240"
    "1D"  => "D"
    "1W"  => "W"
    "1M"  => "M"
    => "60"

// --- B. Candle Appearance ---
string group_visual = "B. CANDLE APPEARANCE"

// BODY COLORS (Bull/Bear in one line)
bull_body_c = input.color(color.new(color.green, 10), "Bull Body", group=group_visual, inline="BodyColors")
bear_body_c = input.color(color.new(color.red, 10), "Bear Body", group=group_visual, inline="BodyColors")

// WICK & BORDER COLORS (Simplified titles)
border_c = input.color(color.new(color.black, 10), "Body Border", group=group_visual) 
bull_wick_c = input.color(color.new(color.green, 0), "Bull Wick", group=group_visual, inline="WickColors")
bear_wick_c = input.color(color.new(color.red, 0), "Bear Wick", group=group_visual, inline="WickColors")


// --- C. Position & Size ---
string group_position = "C. POSITION & SIZE"

offset_val = input.int(15, 'Padding (from chart)', minval = 1, group=group_position, inline="pos_set")
buffer_val = input.int(1, 'Spacing', minval = 1, maxval = 4, group=group_position, inline="pos_set")
width_val = input.int(1, 'Width (1-4)', minval = 1, maxval = 4, group=group_position, inline="pos_set") * 2 

// --- D. Labels & Timer ---
string group_label = "D. LABELS & TIMER"

// HTF Label Settings (Compact group)
show_htf_label = input.bool(true, 'Show HTF', group=group_label, inline='LabelGroup')
htf_label_size = input.string(size.normal, 'Size', [size.tiny, size.small, size.normal, size.large, size.huge], group=group_label, inline='LabelGroup')
htf_label_color = input.color(color.new(color.white, 0), 'Color', group=group_label, inline='LabelGroup')

// Countdown Timer Settings (Compact group)
show_timer = input.bool(true, 'Show Timer', group=group_label, inline='TimerGroup')
timer_color = input.color(color.new(color.gray, 0), 'Timer Text Color', group=group_label, inline='TimerGroup') 
timer_size = input.string(size.normal, 'Size', [size.tiny, size.small, size.normal, size.large, size.huge], group=group_label, inline='TimerGroup')
timer_bg_color = color.new(color.black, 100)


// --- INITIALIZATION ---
var CandleSettings SettingsHTF = CandleSettings.new()
SettingsHTF.htf := htfTimeframe

var array<Candle> candles_set = array.new<Candle>(0)
var CandleSet htf_single = CandleSet.new()
htf_single.settings := SettingsHTF
htf_single.candles := candles_set
Helper helper = Helper.new()
color color_transparent = #ffffff00

// ===================================
// HELPER FUNCTIONS
// ===================================

method RemainingTime(Helper helper, string HTF) =>
	helper.name := HTF
	if barstate.isrealtime
		timeRemaining = (time_close(HTF) - timenow) / 1000
		days = math.floor(timeRemaining / 86400)
		hours = math.floor((timeRemaining - days * 86400) / 3600)
		minutes = math.floor((timeRemaining - days * 86400 - hours * 3600) / 60)
		seconds = math.floor(timeRemaining - days * 86400 - hours * 3600 - minutes * 60)

		r = str.tostring(seconds, '00')
		if minutes > 0 or hours > 0 or days > 0
			r := str.tostring(minutes, '00') + ':' + r
		if hours > 0 or days > 0
			r := str.tostring(hours, '00') + ':' + r
		if days > 0
			r := str.tostring(days) + 'D ' + r
		r
	else
		'n/a'

method HTFName(Helper helper, string HTF) =>
	helper.name := 'HTFName'
	formatted = HTF

	seconds = timeframe.in_seconds(HTF)
	if seconds < 60
		formatted := str.tostring(seconds) + 's'
	else if seconds / 60 < 60
		formatted := str.tostring(seconds / 60) + 'm'
	else if seconds / 60 / 60 < 24
		formatted := str.tostring(seconds / 60 / 60) + 'H'
	formatted

method ValidTimeframe(Helper helper, string HTF) =>
	helper.name := HTF
	n1 = timeframe.in_seconds()
	n2 = timeframe.in_seconds(HTF)
	n1 < n2 and math.round(n2 / n1) == n2 / n1

method CandleSetHigh(array<Candle> candles) =>
	float _h = 0.0
	if array.size(candles) > 0
		for i = 0 to array.size(candles) - 1 by 1
			_h := math.max(_h, array.get(candles, i).h)
	_h
    
method CandleSetLow(array<Candle> candles) =>
    float _l = high
    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            _l := math.min(_l, array.get(candles, i).l)
    _l
// ===================================
// DRAWING LOGIC
// ===================================

method UpdateTime(CandleSet candleSet) =>
	if show_timer and (barstate.isrealtime or barstate.islast)
		string tmr = helper.RemainingTime(candleSet.settings.htf)

		if not na(candleSet.tfTimerTop)
			candleSet.tfTimerTop.set_text(tmr)
	candleSet

method Reorder(CandleSet candleSet, int offset) =>
	size = candleSet.candles.size()

	// 1. Draw and shift candles
	if size > 0
		for i = 0 to size - 1 by 1
			Candle candle = array.get(candleSet.candles, i)
			t_buffer = offset + (width_val + buffer_val) * (size - i - 1)

			box.set_left(candle.body, bar_index + t_buffer)
			box.set_right(candle.body, bar_index + width_val + t_buffer)
			line.set_x1(candle.wick_up, bar_index + width_val / 2 + t_buffer)
			line.set_x2(candle.wick_up, bar_index + width_val / 2 + t_buffer)
			line.set_x1(candle.wick_down, bar_index + width_val / 2 + t_buffer)
			line.set_x2(candle.wick_down, bar_index + width_val / 2 + t_buffer)

	// 2. Set labels
	if show_htf_label or show_timer
		// Get highest and lowest points for positioning
		top = htf_single.candles.CandleSetHigh()
		bottom = htf_single.candles.CandleSetLow()
        
		// X position is the center of the newest candle
		left = bar_index + offset + (width_val / 2)

		if show_htf_label
			string lblt = helper.HTFName(candleSet.settings.htf)
            // HTF: Positioned high above the candle
            float htf_y = top * 1.0005 

			if not na(candleSet.tfNameTop)
				candleSet.tfNameTop.set_xy(left, htf_y)
				candleSet.tfNameTop.set_text(lblt)
			else
				candleSet.tfNameTop := label.new(left, htf_y, lblt, color = color_transparent, textcolor = htf_label_color, style = label.style_label_down, size = htf_label_size)
        
		if show_timer
			string tmr = helper.RemainingTime(candleSet.settings.htf)
            
            // TIMER: Positioned lower below the lowest Low
            float timer_y = bottom * 0.9990

			if not na(candleSet.tfTimerTop)
				// Use left (center of candle) and timer_y (bottom)
				candleSet.tfTimerTop.set_xy(left, timer_y)
				candleSet.tfTimerTop.set_text(tmr)
			else
				// Timer with transparent background, no pointer
				candleSet.tfTimerTop := label.new(left, timer_y, tmr, color = timer_bg_color, textcolor = timer_color, style = label.style_none, size = timer_size)

	candleSet

method Monitor(CandleSet candleSet) =>
	HTFBarTime = time(candleSet.settings.htf, 'america/New_York')
	isNewHTFCandle = ta.change(HTFBarTime) > 0

	if isNewHTFCandle
		// Create a new candle
		Candle candle = Candle.new()
		candle.o := open
		candle.c := close
		candle.h := high
		candle.l := low
		candle.o_idx := bar_index

		bull = candle.c > candle.o
		wick_color = bull ? bull_wick_c : bear_wick_c 

		// Body: fixed black border (border_c)
		candle.body := box.new(bar_index, math.max(candle.o, candle.c), bar_index + 2, math.min(candle.o, candle.c), border_c, 1, bgcolor = bull ? bull_body_c : bear_body_c)
		
		// Wicks: dynamic color (wick_color)
		candle.wick_up := line.new(bar_index + 1, candle.h, bar_index, math.max(candle.o, candle.c), color = wick_color)
		candle.wick_down := line.new(bar_index + 1, math.min(candle.o, candle.c), bar_index, candle.l, color = wick_color)

		candleSet.candles.unshift(candle) // Add new candle to the front

		// Remove the oldest candle
		if candleSet.candles.size() > max_display_count
			Candle delCandle = array.pop(candleSet.candles)
			box.delete(delCandle.body)
			line.delete(delCandle.wick_up)
			line.delete(delCandle.wick_down)

	candleSet

method Update(CandleSet candleSet, int offset) =>
	if candleSet.candles.size() > 0
		Candle candle = candleSet.candles.first()

		// 1. Update High, Low, Close for the current candle
		candle.h := math.max(high, candle.h)
		candle.l := math.min(low, candle.l)
		candle.c := close

		bull = candle.c > candle.o
		wick_color = bull ? bull_wick_c : bear_wick_c 

		// 2. Update shape and color
		box.set_top(candle.body, math.max(candle.o, candle.c))
		box.set_bottom(candle.body, math.min(candle.o, candle.c))
		box.set_bgcolor(candle.body, bull ? bull_body_c : bear_body_c)
		box.set_border_color(candle.body, border_c) 
		
		line.set_color(candle.wick_up, wick_color) 
		line.set_color(candle.wick_down, wick_color) 
		
		line.set_y1(candle.wick_up, candle.h)
		line.set_y2(candle.wick_up, math.max(candle.o, candle.c))
		line.set_y1(candle.wick_down, math.min(candle.o, candle.c))
		line.set_y2(candle.wick_down, candle.l)

		// 3. Shift and labels
		if barstate.isrealtime or barstate.islast
			candleSet.Reorder(offset)

	candleSet

// ===================================
// MAIN LOGIC
// ===================================

CandleSet candleSet = htf_single

if helper.ValidTimeframe(candleSet.settings.htf)
	// 1. Create new candle and remove old ones
	candleSet.Monitor()

	// 2. Update candles and shift
	candleSet.Update(offset_val)

	// 3. Update timer
	candleSet.UpdateTime()
